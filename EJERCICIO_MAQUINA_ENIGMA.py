# -*- coding: utf-8 -*-

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IDjaQUP7T6l55H0v_-c9CauyboXbJKe5

# 27-Tarea Final 02 
## Máquina Enigma

## Grupo # <font color='green'>____A____</font> 


## Integrantes: 
* <font color='green'>____Jenniffer Paredes____</font>
* <font color='green'>____Christian Bocaz____</font> 
* <font color='green'>____Milton Saavedra____</font> 
* <font color='green'>____Daniel González____</font> 
* <font color='green'>____Katalina Lizana____</font> 
* <font color='green'>____Joao Guzmán____</font>

¡Bienvenido Agente! Nos encontramos en pleno conflicto y hemos encontrado los planos de una  [Máquina Enigma](https://es.wikipedia.org/wiki/Enigma_(máquina)) enemiga. Necesitamos que configures una máquina que nos ayude a descifrar los mensajes que interceptamos.
La máquina posee tres rotores y un reflector. Cada rotor es un disco circular plano con 26 contactos eléctricos en cada cara, uno por cada letra del alfabeto. Cada contacto de una cara está conectado o cableado a un contacto diferente de la cara contraria. Por ejemplo, en un rotor en particular, el contacto número 1 de una cara puede estar conectado con el contacto número 14 en la otra cara y el contacto número 5 de una cara con el número 22 de la otra.

Como cada rotor está en contacto con el otro, lo anterior permite ir cambiando el indice de las letras de entrada, configurando así una criptografía muy compleja de resolver en aquellos tiempos. Estos rotores se conocen como.

* Rotor derecho
* Rotor medio
* Rotor izquierdo
* Reflector

Mira este video para que entiendas mejor el concepto le la [Máquina Enigma](https://youtu.be/VnsTHAH5yAE).

## Estructura de los rotores

Los tres rotores (izquierdo, medio y derecho) tienen el alfabeto de 26 letras ordenadas en su sección de entrada y las mismas 26 letras desordenadas en su sección de salida.<br>
El reflector, posee solo 13 letra, las cuales están repetidas 2 veces cada una y están repartidas aleatoriamente en el dispositivo. El punto en donde la señal del rotor izquierdo pasa al reflector, determina la letra de entrada; la salida será por la letra que conforma la pareja.

Esta es la configuración que hemos encontrado:

```python
'''
Reflector  Rot_izd   Rot_med   Rot_der  Teclado
    A       A - E     A - A     A - B      A
    B       B - K     B - J     B - D      B
    C       C - M     C - D     C - F      C
    D       D - F     D - K     D - H      D
    E       E - L     E - S     E - J      E
    F       F - G     F - I     F - L      F
    G       G - D     G - R     G - C      G
    D       H - Q     H - U     H - P      H
    I       I - V     I - X     I - R      I
    J       J - Z     J - B     J - T      J
    K       K - N     K - L     K - X      K
    G       L - T     L - H     L - V      L
    M       M - O     M - W     M - Z      M
    K       N - W     N - T     N - N      N
    M       O - Y     O - M     O - Y      O
    I       P - H     P - C     P - E      P
    E       Q - X     Q - Q     Q - I      Q
    B       R - U     R - G     R - W      R
    F       S - S     S - Z     S - G      S
    T       T - P     T - N     T - A      T
    C       U - A     U - P     U - K      U
    V       V - I     V - Y     V - M      V
    V       W - B     W - F     W - U      W
    J       X - R     X - V     X - S      X
    A       Y - C     Y - O     Y - Q      Y
    T       Z - J     Z - E     Z - O      Z
'''
```

## Funcionamiento general
Cada vez que un usuario presiona una tecla en el Teclado (columna derecha del diagrama anterior), ocurre lo siguiente:
1. El Rotor_derecho avanza una posición hacia arriba, i.e., la combinación 'A - B' pasa al final de la lista y el primer lugar lo ocupa 'B - D'
2. Se obtiene la posición en la lista (Teclado) de la tecla presionada por el operador . 
3. La posición obtenida en el punto 2, se utiliza para buscar la letra la sección derecha del Rotor_derecho que está en la misma posición (frente a frente). En esa posición existe una letra a la cual llamaremos Letra_entrada.
4. En el Rotor_derecho se busca la posición de la Letra_entrada en la sección de salida. Esta será la posición de salida del rotor.
5. Se repiten los pasos amteriores 3 y 4 en el Rotor_medio; esta vez la posición de entrada en equivalente a la posición de salida del punto 4.
6. Se repiten los pasos amteriores 3 y 4 en el Rotor_izquierdo.
7. Con la posición de salida del Rotor_izquierdo se entra en el Reflector. En la posición de entrada en el Reflector, hay una letra. Se buscará entonces la otra letra equivalente dentro del Reflector. Esto determinará la posición de salida.
8. Con esta posición (la de salida del Reflector) se invierte el proceso, es decir, se busca la letra que está en contacto con el rotor anterior y se busca la posición de dicha letra en la salida del rotor. Este proceso se repita sucesivamente con los rotores izquierdo, medio y derecho.
9. La posición de salida del Rotor_derecho marcará la posicón en el Teclado, indicando la letra encriptada.

## Algunos detalles adicionales
Cada vez que procesamos una letra, primero rotamos una posición el Rotor_derecho (hacia arriba).
Cuando la letra "V" de la componente ordenada (iquierza) del Rotor_derecho alcanza la posición inicial en la lista, se gira una posición hacia arriba el Rotor_medio.
Lo mismo ocurre cuando la letra 'Q' de la componente ordenada (iquierza) del Rotor_medio llega al inicio, en este caso, se avanza una posición hacia arriba el Rotor_izquierdo.

## Más detalles
Esto no termina aquí. Para hacer más difícil el trabajo de desencriptación, la máquina tiene la posibilidad de fijar la posición inicial de los tres rotores centrales. Para esto se elige una clave de tres letras, las cuales marcan la posición inicial de la primera letra de la sección ordenada (izquierda) de cada rotor. Por ejemplo la clave <font color='red'>'MCK'</font> dejaría los rotores de la siguiente forma:

```Python
'''
Reflector  Rot_izd   Rot_med   Rot_der  Teclado
    A       M - O     C - D     K - X      A
    B       N - W     D - K     L - V      B
    C       O - Y     E - S     M - Z      C
    D       P - H     F - I     N - N      D
    E       Q - X     G - R     O - Y      E
    F       R - U     H - U     P - E      F
    G       S - S     I - X     Q - I      G
    D       T - P     J - B     R - W      H
    I       U - A     K - L     S - G      I
    J       V - I     L - H     T - A      J
    K       W - B     M - W     U - K      K
    G       X - R     N - T     V - M      L
    M       Y - C     O - M     W - U      M
    K       Z - J     P - C     X - S      N
    M       A - E     Q - Q     Y - Q      O
    I       B - K     R - G     Z - O      P
    E       C - M     S - Z     A - B      Q
    B       D - F     T - N     B - D      R
    F       E - L     U - P     C - F      S
    T       F - G     V - Y     D - H      T
    C       G - D     W - F     E - J      U
    V       H - Q     X - V     F - L      V
    V       I - V     Y - O     G - C      W
    J       J - Z     Z - E     H - P      X
    A       K - N     A - A     I - R      Y
    T       L - T     B - J     J - T      Z
'''
```
Fíjate que ni el Teclado ni el Reflector cambian, solo los rotores izquierdo, medio y derecho.

Aquí te dejamos algunos videos con la misma explicación:
    
[Criptografía - Máquina Enigma, funcionamiento detallado](https://youtu.be/XK_1gUo8YDE)

## <font color='green'>Misión</font>

Con los planos obtenidos, debes programar en Python tu propia Máquina Enigma. Cuando hayas terminado, se te dará un mensaje cifrado que deberás decodificar para aprobar el curso.

Tu misión consiste en lo siguiente:<br>
1. Programar la lógica de la máquina utilizando la información de los rotores conseguidos
2. Ingresar una clave inicial (te será dada)
3. Decodificar el mensaje correctamente

Tips:

1. Con la clave <font color='red'>'MCK'</font>, la frace **"ENIGMA REVEALED"** debiera encriptarse como **'QMJIDOMZWZJFJR"** y viceversa.
2. Recuerda usa stackoverflow e internet para buscar sintaxis y funciones.
3. Divide el desafío en tantos problemas pequeños como puedas.

## <font color='orange'>Tarea 1:</font> Cablea los rotores

Crea los cableados de los rotores 

TIP:
1. Crea lista con las secuencias
2. Utiliza los strings proporcionados y conviértelos a listas con **split( )**
"""

# Componente ordenada de los rotores
st = 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'

teclado = st.split(" ")

# Creamos el reflector
rf = 'A B C D E F G D I J K G M K M I E B F T C V V J A T'

# Convierte el string 'rf' en una lista
reflector = rf.split(" ")
reflector

# Creamos el rotor derecho
# Este string contiene el alfabeto de salida (desordenado)
str_r_derecha = 'B D F H J L C P R T X V Z N Y E I W G A K M U S Q O'

# Convierte el string 'rf' en una lista
r_der_salida = str_r_derecha.split(" ")
r_der_salida

# Creamos el rotor medio
# Este string contiene el alfabeto de salida (desordenado)
str_r_medio = 'A J D K S I R U X B L H W T M C Q G Z N P Y F V O E'

# Convierte el string 'rf' en una lista
r_medio_salida = str_r_medio.split(" ")
r_medio_salida

# Creamos el rotor izquierdo
# Este string contiene el alfabeto de salida (desordenado)
str_r_izq = 'E K M F L G D Q V Z N T O W Y H X U S P A I B R C J'

# Convierte el string 'rf' en una lista
r_izq_salida = str_r_izq.split(" ")
r_izq_salida

"""## <font color='orange'>Tarea 2:</font> Arma los rotores

Crea tres listas vacias para almacenar los rotores armados
Recuerda que cada rotor tiene una componente ordenada y otra desordenada. La ordenada va la izquierda y desordenada a la derecha.

TIP:
1. La estructura a obtener debiera ser una lista de listas. Por ejemplo, el rotor_izquierdo debería verse así:

```python
[['A', 'E'],
 ['B', 'K'],
 ['C', 'M'],
 ['D', 'F'],
 ['E', 'L'],
 ['F', 'G'],
 ['G', 'D'],
 ['H', 'Q'],
 ['I', 'V'],
 ['J', 'Z'],
 ['K', 'N'],
 ['L', 'T'],
 ['M', 'O'],
 ['N', 'W'],
 ['O', 'Y'],
 ['P', 'H'],
 ['Q', 'X'],
 ['R', 'U'],
 ['S', 'S'],
 ['T', 'P'],
 ['U', 'A'],
 ['V', 'I'],
 ['W', 'B'],
 ['X', 'R'],
 ['Y', 'C'],
 ['Z', 'J']]
```
"""

# Crea tres listas vacias para almacenar los rotores armados
# Recuerda que cada rotor tendré una componente ordenada y otra desordenada
disco_derecho = []
disco_izquierdo = []
disco_medio = []

"""Crea tres listas vacias para almacenar los rotores armados
Recuerda que cada rotor tiene una componente ordenada y otra desordenada. Ordenada a la izquierda y desordenada a la derecha.

TIP:
1. Utiliza un ciclo **for** para añadir los pares de elementos  (ordenado - desordenado) en cada rotor. 
2. Utiliza las listas que creamos anteriormente
3. Utiliza la función zip( ) para unir las lista
4. Utiliza la función **append( )** e *indexing* 

```python
for i in zip(lista_1, lista_2):
    disco.append([i[0], i[1]])
```
"""

# Se define una funcion para realizar la tarea de cración de un disco

def crear_disco(disco, lista_1, lista_2):
    disco.clear()
    for i in zip(lista_1, lista_2):
        disco.append([i[0], i[1]])
    return disco

# Con la función creada, sólo basta llamarla para cada caso.

disco_izquierdo = crear_disco(disco_izquierdo, teclado, r_izq_salida)
disco_medio = crear_disco(disco_medio, teclado, r_medio_salida)
disco_derecho = crear_disco(disco_derecho, teclado, r_der_salida)

"""Imprime la configuración del Reflector, de los tres rotores y del Teclado. De la misma forma que en la instrucciones iniciales.

Tip:
1. Utiliza función **print( )** y **f-strings** para el correcto formateo
2. Utiliza **zip( )** nuevamente para agrupar todas las listas. Luego recórrelas con un ciclo **for** para imprimirlas.
"""

print(f'Reflector  Rotor_izd   Rotor_med   Rotor_der   Teclado')

for i in zip(reflector, disco_izquierdo, disco_medio, disco_derecho, teclado):
    print(f'    {i[0]}        {i[1][0]} - {i[1][1]}   '
          f'    {i[2][0]} - {i[2][1]}    '
          f'   {i[3][0]} - {i[3][1]}        {i[4][0]}')

"""## <font color='orange'>Tarea 3:</font> Crea una función para girar los rotores

Crea una función llamada **avanza_rotor**. La función debe girar los rotores hacia arriba. Créala de esta forma:

```python
def avanza_rotor(disco, paso):
```
Entrada:<br>
**disco**: corresponde a la lista con la información del rotor a avanzar. Esta es una lista de listas.<br>
**paso**. Esta variable indicará la cantidad de pasos que debe avanzar el rotor.

Salida:<br>
La funión deve devolver el rotor (lista de listas) rotado **paso** pasos.

TIP:
1. Recuerda el uso de **pop( )** y **append( )** en las listas
"""

def avanza_rotor(disco, paso):
    for j in range(paso):
        disco.append(disco[0])
        disco.pop(0)

disco_derecho

"""## <font color='orange'>Tarea 4:</font> Crea una función para posicionar los rotores según la clave inicial

Crea una función que configure la posición inicial de los rotores. Llámala **conf_rotores** de esta forma:

```python
def conf_rotores(clave_inicial):
```
Entrada:<br>
**clave_inicial**: corresponde a un string de tres letras.<br>

A partir de la clave inicial se rotan los tres rotores (izquierdo, medio y derecho).

Salida:<br>
La funión debe devolver los tres rotores posicionados según la clave ingresada.

Tip:
1. Necesitarás usa un ciclo **while** cuya condición de salida sea que la letra izquierda del primer par de letras de cada rotor coincida con la letra correspondiente de la clave ingresada.
2. No es necesario que pases los rotores (lista) como argumentos ya que esta estrcutura tiene caracter *global* en Python
"""

def conf_rotores(clave_inicial, verbose=True):

    while disco_izquierdo[0][0] != clave_inicial[0]:
        avanza_rotor(disco_izquierdo, 1)

    while disco_medio[0][0] != clave_inicial[1]:
        avanza_rotor(disco_medio, 1)

    while disco_derecho[0][0] != clave_inicial[2]:
        avanza_rotor(disco_derecho, 1)

    return disco_izquierdo, disco_medio, disco_derecho

# Imprime la nueva configuración de rotores
# Este codigo lo deberías haber hecho más arriba
print(f'Reflector  Rotor_izd   Rotor_med   Rotor_der   Teclado')

# Tu código aquí ...

for i in zip(reflector, disco_izquierdo, disco_medio, disco_derecho, teclado):
    print(f'    {i[0]}        '
          f'{i[1][0]} - {i[1][1]}       '
          f'{i[2][0]} - {i[2][1]}       '
          f'{i[3][0]} - {i[3][1]}        '
          f'{i[4][0]}')

# Además colocamos las posiciones de los elementos
# para comprobar los recorridos

print(f'       Reflector  Rotor_izd   Rotor_med   Rotor_der   Teclado')
for i in zip(reflector, disco_izquierdo, disco_medio, disco_derecho, teclado):
    print(f'    {str(teclado.index(i[4])).zfill(2)}    '
          f'{i[0]}        {i[1][0]} - {i[1][1]}       '
          f'{i[2][0]} - {i[2][1]}       {i[3][0]} - {i[3][1]}        '
          f'{i[4][0]}    {str(teclado.index(i[4])).zfill(2)}')

"""## <font color='orange'>Tarea 5:</font> Crea funciones para pasar señales por los rotores

Crea tres funciones llamadas **pasa_senal_ida**, **pasa_senal_vuelta** y **pasa_senal_ida** y **indice_reflextor** de esta forma:

```python
def pasa_senal_ida(rotor, indice):

    
def pasa_senal_vuelta(rotor, indice):
    
    
def indice_reflextor(rotor, indice):
    
```
Entrada:<br>
**rotor**: corresponde a la lista con la información del rotor. Esta es una lista de listas.<br>
**indice**. Es el punto de contacto en el rotor: En el caso de **pasa_senal_ida** será por la derecha y en el caso de **pasa_senal_vuelta** será por la izquierda

Salida:<br>
Las funciones devuelven el indice de salida del rotor
"""

def pasa_senal_ida(rotor, indice):
    indice_salida = 0
    while not rotor[indice_salida][0] == rotor[indice][1]:
        indice_salida += 1

    return indice_salida


def pasa_senal_vuelta(rotor, indice):
    indice_salida = 0
    while not rotor[indice_salida][1] == rotor[indice][0]:
        indice_salida += 1

    return indice_salida


def indice_reflextor(rotor, indice):
    for i in range(len(reflector)):
        if reflector[i] == reflector[indice] and i != indice:
            indice_salida = i

    return indice_salida

"""## <font color='orange'>Tarea 6:</font> Armando la ENIGMA

Bien hecho hasta acá Hacker. Ahora debes armar la máquina.

Crea una función **enigma**

```python
def enigma(mensaje, clave):
```
Entrada:<br>
**mensaje**: corresponde a un strig que contiene el mensaje a codificar. Recuerda que no se usaban ni numeros ni caractares especiales. Solo lo que el teclado de entrada pudiera escribir.<br>
**clave**. Es la clave para posicionar los rotores al inicio

Salida:<br>
Mensaje cifrado
"""

def enigma(mensaje, clave):

    mensaje_cifrado = ''

    # Rotamos discos a posición clave
    conf_rotores(clave, verbose=True)

    # Cada vez que procesamos una letra, primero
    for i in range(0, len(mensaje)):

        # Cuando la letra "V" del la componente
        # de salida del rotor derecho alcanza
        # la posición inicial, se gira una posición el rotor central
        if disco_derecho[0][0] == 'V':

            # Lo mismo ocurre cuando la letra 'Q'
            # del rotor centra llega al inicio,
            if disco_medio[0][0] == 'Q':

                # se avanza una posición ambos componentes del rotor izquierdo
                avanza_rotor(disco_izquierdo, 1)
            avanza_rotor(disco_medio, 1)

        # rotamos las dos componentes del disco derecho
        avanza_rotor(disco_derecho, 1)

        # ida del teclado al rotor derecho
        indice_teclado = teclado.index(mensaje[i])

        # ida en rotor derecho
        indice_salida = pasa_senal_ida(disco_derecho, indice_teclado)

        # ida en rotor medio
        indice_salida = pasa_senal_ida(disco_medio, indice_salida)

        # ida en rotor izquierdo
        indice_salida = pasa_senal_ida(disco_izquierdo, indice_salida)

        # rebote en rotor reflector
        indice_salida = indice_reflextor(disco_izquierdo, indice_salida)

        # vuelta en rotor izquierdo
        indice_salida = pasa_senal_vuelta(disco_izquierdo, indice_salida)

        # vuelta en rotor medio
        indice_salida = pasa_senal_vuelta(disco_medio, indice_salida)

        # vuelta en rotor derecho
        indice_salida = pasa_senal_vuelta(disco_derecho, indice_salida)

        # Vuelta LETRA DE SALIDA
        Letra_salida_teclado = teclado[indice_salida]
        mensaje_cifrado = mensaje_cifrado + Letra_salida_teclado
        # print(mensaje_cifrado + str('\n'))
        i += 1

    return mensaje_cifrado

# Probemos si funciona

enigma('QMJIDOMZWZJFJR', 'MCK')

"""El resultado esperado es:
```python
ENIGMAREVEALED
```
"""

# Funciona para textos más largos?

enigma('DVTHVUVYAGHBRJGQTHBOWIYL', 'MCK')

"""#<font color="orange">Experimentos/Reflexiones</font>

Todo el código está escrito siguiendo PEP8.

Se ha buscado información acerca del significado del término "verbose" en las funciones, y se ha desarrollado una función que lo implemente.

[Qué es verbose en una función](https://ask.openstack.org/en/question/79373/what-does-it-mean-verbosetrue/) para implementar verbose en la función conf_rotores().


```python
def conf_rotores(clave_inicial, verbose=True):
    while r_derecha[0][0] != clave_inicial[2]:
        avanza_rotor(r_derecha, 1)

    while r_medio[0][0] != clave_inicial[1]:
        avanza_rotor(r_medio, 1)

    while r_izq[0][0] != clave_inicial[0]:
        avanza_rotor(r_izq, 1)

    if verbose:
        print(f'Reflector  Rotor_izd   Rotor_med   Rotor_der   Teclado')
        for i in zip(rf, r_izq, r_medio, r_derecha, st):
            print(f' {i[0]} {"":7}  {i[1]}  {i[2]} {i[3]} {"":2} {i[4]}')

    return

```

Para realizar la **Tarea 4** correspondiente a la *máquina enigma*, en la cual se debía crear una funcipon para posicionar los rotores según la clave inicial, se puedo observar que para creación de los **while** no solo se podía utilizar *!=* para señalar la diferenciación, sino que al utilizar *while not* estas eran equivalentes.

A continuación se puede ver el código correspondiente a lo mencionado:

```python
def conf_rotores(clave_inicial, verbose=True):

    while not disco_izquierdo[0][0] clave_inicial[0]:
        avanza_rotor(disco_izquierdo, 1)

    while not disco_medio[0][0] clave_inicial[1]:
        avanza_rotor(disco_medio, 1)

    while not disco_derecho[0][0] clave_inicial[2]:
        avanza_rotor(disco_derecho, 1)

    return disco_izquierdo, disco_medio, disco_derecho
```

Adicionalmente, se ha buscado información respecto de las listas de comprensión, con la finalidad de hacer mas "pythonista" el código e implementarlo en las funciones de paso de señal y reflector.

[Listas de comprensión](https://stackoverflow.com/questions/290424/filter-a-python-list-by-predicate) para búsquedas dentro de listas

[Lista de comprensión](https://stackoverflow.com/questions/6294179/how-to-find-all-occurrences-of-an-element-in-a-list) para buscar todos los índices de una ocurrencia.

```python
def pasa_senal_ida(rotor, indice):
    return next(rotor.index(x) for x in rotor if x[0] == rotor[indice][1])

```
```python
def pasa_senal_vuelta(rotor, indice):
    return next(rotor.index(x) for x in rotor if x[1] == rotor[indice][0])

```
```python
def indice_reflextor(disco, indice):
    indices = [i for i, x in enumerate(disco) if x == disco[indice]]
    indices.pop(indices.index(indice))
    return indices[0]
    
```
"""
